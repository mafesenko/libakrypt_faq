#include <stdio.h>
#include <libakrypt.h>
#include <libakrypt-base.h>

int main() {
    /*Структура для хранения контекста ключа*/
    struct bckey ekey, ikey;

    static ak_uint8 keyAnnexA[32] = { 0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01, 0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe, 
        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88 
    };  

    static ak_uint8 keyAnnexABlockReverse[32] = { 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,  
        0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01, 0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe 
    };

    ak_bckey_create_magma(&ekey);
    ak_bckey_set_key(&ekey, keyAnnexA, sizeof(keyAnnexA));
    
    ak_bckey_create_magma(&ikey);
    ak_bckey_set_key(&ikey, keyAnnexABlockReverse, sizeof(keyAnnexABlockReverse));

    static ak_uint8 associated[41] = { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,       
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xEA 
    };

    static ak_uint8 plain[67] = { 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11,  
        0x0A, 0xFF, 0xEE, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,   
        0x00, 0x0A, 0xFF, 0xEE, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11,
        0x11, 0x00, 0x0A, 0xFF, 0xEE, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,     
        0xCC, 0xBB, 0xAA 
    };

    ak_uint8 ina_ptr[32 + sizeof(associated)], inp[32 + sizeof(plain)], otp[32 + sizeof(plain)];   
    ak_uint8 out_ptr[32 + sizeof(plain)], icode[16];
    void* inp_ptr = inp;
    void* otp_ptr = otp;

    int len = 8;
    
    static ak_uint8 iv128[16] = { 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11 
    };

    memcpy(ina_ptr, associated, sizeof(associated));    
    memcpy(inp_ptr, plain, sizeof(plain));

    if (ak_error_ok != ak_bckey_encrypt_xtsmac(&ekey, &ikey, ina_ptr, sizeof(associated), inp_ptr, otp_ptr, len, iv128, sizeof(iv128), icode, 16))
        return ak_error_get_value();     
    
    ak_uint8 out[32 + sizeof(plain)], ecode[16];
    memset(out, 0, sizeof(plain));
    ak_bckey_decrypt_xtsmac(&ekey, &ikey, ina_ptr, sizeof(associated), otp_ptr, out, len, iv128, sizeof(iv128), icode, 16 );

    if(ak_ptr_is_equal(plain, out, len) != ak_true) {
        printf("Encrypted and decrypted data are different\n");
        return ak_error_not_equal_data;
    }

    printf("Data sucessfully encrypt and decrypt\n");
    return 0;
}
